#region imports
import sys
sys.path.append('D:\\PRG\\Python36\\lib\\site-packages')
import os
import Draft    #FreeCAD modul
from PySide import QtGui, QtCore
from varname import nameof
from math import sqrt
from pyquaternion import Quaternion
from shapely.geometry import Point, Polygon
from PySide import QtGui
#endregion

#region description
""" 
eljaras a szigetelovel megnovelt atmroju huzalok elhelyezesere a horonyban

horonygeometria V1 egy sketchben kesz, parametrikusan mukodik
bemeno parameterek az eljarashoz

Forgórész:
CoreDinn        belső átm
CoreThk            Valvastags.

Referencia
CoreDout REF!!        külső átm

Horony V1
R1 alsó rádiusz
H1 teljes horonymagasság
B1 felső horonyszélesség
L1 felső érintési pont távolság

Referenciaméretek:
V1P1 REF!!    alsó körív középpontja
V1P2 REF!!    felső szakasz középpontja

"""
#endregion

#region functions

def wloc_in_groove(): # huzal pozíciók szamlaloja a horonyban 
    x=0
    y=0
    # y basic incr
    y_sign = 1
    condition1 = True
    condition2 = True
    
    while condition1:    #level1: first pos. y, then neg. y
        #print("cond1")
        condition1 = (y>=0)
        while condition2:#level 2 counting y
            #őőő("cond2")
            condition2 = False
            while wire_condition(x,y): #level 3 counting x
                #őőő("cond3")
                condition2 = True
                x += 1
            x=0
            y+=(1*y_sign)

        y_sign = -1
        y = y_sign
        condition2 = True

def groove_contour(): # a horony geometria bekerese
    obj = App.ActiveDocument.getObject("GrooveV1")
    #őőő(obj.Name)
    return obj.Shape.discretize(int(obj.Shape.Length/0.6))

def dim_settings(groove): #bemeno parameterek beallitasa a modellben
    global CoreDinn, CoreThk, R1, H1, B1, L1
    
    App.ActiveDocument.getObject("StatCore").setDatum(nameof(CoreDinn),CoreDinn)
    App.ActiveDocument.getObject("StatCore").setDatum(nameof(CoreThk),CoreThk)
    
    App.ActiveDocument.getObject(groove).setDatum(nameof(R1),R1)
    App.ActiveDocument.getObject(groove).setDatum(nameof(H1),H1)
    App.ActiveDocument.getObject(groove).setDatum(nameof(B1),B1)
    App.ActiveDocument.getObject(groove).setDatum(nameof(L1),L1)

def def_quaternion(v1,v2): #ket vektor kozotti elmozdulas quaternion eloallitasa
    """quaternion eloallitasa ket vektorbol
    két nem normalizált vektorbol eloallitja a normalizalt quaterniont
    """

    if(abs(v1.normalize().dot(v2.normalize())-1) < 0.0001):
        #párhuzamos, irany marad
        return_tuple = (0,0,0,1)
        return return_tuple

    elif(abs(v1.normalize().dot(v2.normalize())+1) < 0.0001):
        new_q = Quaternion(axis=[0, 0, 1], degrees=180) # (pyquaternion)
        return_tuple = (round(new_q[1],6),round(new_q[2],6),round(new_q[3],0),round(new_q[0],0))
        return return_tuple

    else:
        x_vect = v1.cross(v2)
        q_w = sqrt((pow(v1.Length,2)) * (pow(v2.Length,2))) + v1.dot(v2)
        new_q = Quaternion(q_w, x_vect[0], x_vect[1], x_vect[2])
        return_tuple = (round(new_q[1],6),round(new_q[2],6),round(new_q[3],0),round(new_q[0],0))
        return return_tuple

def wire_condition(x,y): # huzal vizsgálata, hogy a hornyon belul helyezkedik-e el
    global A, y_incr, gr_cont_pts, Dk, wire_collection
    pnts = []
    if y%2: # páratlan
    #centers of circles
        x_circ = (x + 0.5)*A
        y_circ = y*y_incr*A
    else: #páros
        x_circ = x*A
        y_circ = y*y_incr*A

    circ_cont = circ_contour(x_circ,y_circ,Dk/2)    #a kor konturpontjait adja vissza

    for pnt_ in circ_cont:
        pnts.append((pnt_[0],pnt_[1],pnt_[2]))

    if Polygon(gr_cont_pts).contains(Polygon(pnts)):
        App.ActiveDocument.getObject("C_BdWires").addObject(wire_collection[-1])
        #mirrored: a vizsgalat csak az x tengely pozitiv ertekeire tortenik. A tukrozotteket automatikusan hozza tesszuk.
        if x_circ != 0:
            pl = App.Placement()
            pl.Rotation.Q=(0,0,0,1)
            pl.Base=App.Vector(-x_circ,y_circ,0)
            wire_collection.append(Draft.makeCircle(radius=Dk/2,placement=pl,face=False,support=None))
            App.ActiveDocument.getObject("C_BdWires").addObject(wire_collection[-1])
    else:
        App.ActiveDocument.removeObject(wire_collection[-1].Name)
        wire_collection.pop()
        return False
 
    return True

def inputbox():
    form.exec_()
    #form.show()
    if form.result==userCancelled:
        raise Exception
    if form.result==userOK:
        pass


def circ_contour(x,y,r): # a kordinatakkal es sugarral kort rajzol, berakja a wire bodyba, es visszaadja a konturpontjait (lokalis??)

    global wire_collection
    #őőő("circ_contour")
    pl = App.Placement()
    pl.Rotation.Q=(0,0,0,1)
    pl.Base=App.Vector(x,y,0)
    #print(pl,r)
    wire_collection.append(Draft.makeCircle(radius=r,placement=pl,face=False,support=None))
    
    #obj = App.ActiveDocument.getObject("GrooveV1")
    #for elem in wire_collection:
    #    print(elem.Placement)
    return wire_collection[-1].Shape.discretize(int(wire_collection[-1].Shape.Length/0.1))

#endregion functions

#region variables
#core dimensions
CoreDinn = 80
CoreThk = 30
CoreName = 'StatCore'
#groove dimensions
R1 = 5
H1 = 15
B1 = 5
L1 = 2
#wire d
Dh = 0.8
#insul thkn
Hsz = 0.1
#outer d
Dk = Dh + 2*Hsz
#gap 
Lr =0.05
#basic dist
A = Dk + Lr

y_incr = A*sqrt(3)/2

wire_collection = []
gr_cont_pts = [] 
gr_cont_pts_v = []
pnts = [] 

#endregion variables

#region main
"""
1 geom meretek atadasa
2 C_BdWires body elhelyezese a horonyban
3 a horony konturjanak lekerdezese osztopontokkal (list, App.Vector)
4 korok poziciojanak elkeszitese
5 korok elkeszitese, konturpontok
vizsgalat
"""
if App.ActiveDocument is not None and App.ActiveDocument.Name == "Workfile":
    pass
else:
    App.open(u"D:/_EGYETEMI/DIPLOMA/OpenCASCADE/exercs/Workfile.FCStd")
    App.setActiveDocument("Workfile")
#1 
dim_settings('GrooveV1')
#2
v_gr_base = App.Vector(0,App.ActiveDocument.getObject("GrooveV1").getDatum("V1P1"),0)
v_gr_dir = App.Vector(0,App.ActiveDocument.getObject("GrooveV1").getDatum("V1P2"),0)
v_dir = v_gr_dir.sub(v_gr_base).normalize()
base_dir = App.Vector(0,1,0)
App.ActiveDocument.getObject("C_BdWires").Placement.Base = v_gr_base
App.ActiveDocument.getObject("C_BdWires").Placement.Rotation = def_quaternion(base_dir,v_dir)
#3
gr_cont_pts_ = groove_contour()

for pts in gr_cont_pts_:
    vec1 = (App.Vector(v_gr_base[0],v_gr_base[1])).sub(App.Vector(pts[0],pts[1]))
    gr_cont_pts.append((vec1[0],vec1[1]))

wloc_in_groove()
#endregion main