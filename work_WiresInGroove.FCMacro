#region imports
import sys
pkg_path = 'D:\\PRG\\Python36\\lib\\site-packages'
path_list_set = set(sys.path)
if pkg_path not in path_list_set:
    sys.path.append(pkg_path)
import os
import FreeCAD, Part, PartDesign, Draft    #FreeCAD modulok
from PySide import QtGui, QtCore
from math import sqrt
from pyquaternion import Quaternion
from shapely.geometry import Point, Polygon
from PySide import QtGui
#endregion

#region description
""" 
eljaras a szigetelovel megnovelt atmeroju huzalok elhelyezesere a horonyban

horonygeometria V1 egy sketchben kesz, parametrikusan mukodik
bemeno parameterek az eljarashoz

Alloresz:
CoreDinn        belso atm
CoreThk            Valvastags.

Referencia
CoreDout REF!!        kulso atm

Horony V1
R1 also radiusz
H1 teljes horonymagassag
B1 felso horonyszelesseg
L1 felso erintesi pont tavolsag

Referenciameretek:
V1P1 REF!!    also koriv kozeppontja
V1P2 REF!!    felso szakasz kozeppontja

"""
#endregion

#region functions

def wloc_in_groove(): # huzal poziciok szamlaloja a horonyban 
    x=0
    y=0
    # y basic incr
    y_sign = 1
    condition1 = True
    condition2 = True
    
    while condition1:    #level1: first pos. y, then neg. y
        condition1 = (y>=0)
        while condition2:#level 2 counting y
            condition2 = False
            while wire_condition(x,y): #level 3 counting x
                condition2 = True
                x += 1
            x=0
            y+=(1*y_sign)
        y_sign = -1
        y = y_sign
        condition2 = True

def groove_contour(): # a horony geometria bekerese
    Shp = App.ActiveDocument.getObject("GrooveV1").Shape
    App.ActiveDocument.recompute()
    return Shp.discretize(int(Shp.Length/0.6))

def dim_settings(groove): #bemeno parameterek beallitasa a modellben
    global CoreDinn, CoreThk, R1, H1, B1, L1

    App.ActiveDocument.getObject("StatCore").setDatum('CoreDinn',CoreDinn)
    App.ActiveDocument.getObject("StatCore").setDatum('CoreThk',CoreThk)
    App.ActiveDocument.getObject(groove).setDatum('R1',R1)
    App.ActiveDocument.getObject(groove).setDatum('H1',H1)
    App.ActiveDocument.getObject(groove).setDatum('B1',B1)
    App.ActiveDocument.getObject(groove).setDatum('L1',L1)
    App.ActiveDocument.recompute()

def def_quaternion(v1,v2): #ket vektor kozotti elmozdulas quaternion eloallitasa
    """quaternion eloallitasa ket vektorbol
    ket nem normalizalt vektorbol eloallitja a normalizalt quaterniont
    """

    if(abs(v1.normalize().dot(v2.normalize())-1) < 0.0001):
        #parhuzamos, irany marad
        return_tuple = (0,0,0,1)
        return return_tuple

    elif(abs(v1.normalize().dot(v2.normalize())+1) < 0.0001):
        new_q = Quaternion(axis=[0, 0, 1], degrees=180) # (pyquaternion)
        return_tuple = (round(new_q[1],6),round(new_q[2],6),round(new_q[3],0),round(new_q[0],0))
        return return_tuple

    else:
        x_vect = v1.cross(v2)
        q_w = sqrt((pow(v1.Length,2)) * (pow(v2.Length,2))) + v1.dot(v2)
        new_q = Quaternion(q_w, x_vect[0], x_vect[1], x_vect[2])
        return_tuple = (round(new_q[1],6),round(new_q[2],6),round(new_q[3],0),round(new_q[0],0))
        return return_tuple

def wire_condition(x,y): # huzal vizsgalata, hogy a hornyon belul helyezkedik-e el
    global A, y_incr, gr_cont_pts, Dk, wire_collection
    pnts = []
    if y%2: # paratlan
    #centers of circles
        x_circ = (x + 0.5)*A
        y_circ = y*y_incr
    else: #paros
        x_circ = x*A
        y_circ = y*y_incr

    circ_cont = circ_contour(x_circ,y_circ,Dk/2)    #a kor konturpontjait adja vissza

    for pnt_ in circ_cont:
        pnts.append((pnt_[0],pnt_[1],pnt_[2]))

    if Polygon(gr_cont_pts).contains(Polygon(pnts)):
        App.ActiveDocument.getObject("C_BdWires").addObject(wire_collection[-1])
        #mirrored: a vizsgalat csak az x tengely pozitiv ertekeire tortenik. A tukrozotteket automatikusan hozza tesszuk.
        if x_circ != 0:
            pl = App.Placement()
            pl.Rotation.Q=(0,0,0,1)
            pl.Base=App.Vector(-x_circ,y_circ,0)
            wire_collection.append(Draft.makeCircle(radius=Dk/2,placement=pl,face=False,support=None))
            App.ActiveDocument.getObject("C_BdWires").addObject(wire_collection[-1])
    else:
        App.ActiveDocument.removeObject(wire_collection[-1].Name)
        wire_collection.pop()
        return False
 
    return True

def circ_contour(x,y,r): # a kordinatakkal es sugarral kort rajzol, berakja a wire bodyba, es visszaadja a konturpontjait (lokalis??)

    global wire_collection
    pl = App.Placement()
    pl.Rotation.Q=(0,0,0,1)
    pl.Base=App.Vector(x,y,0)
    wire_collection.append(Draft.makeCircle(radius=r,placement=pl,face=False,support=None))
    
    return wire_collection[-1].Shape.discretize(int(wire_collection[-1].Shape.Length/0.1))

#endregion functions

#region variables
#core dimensions
CoreDinn = 120
CoreThk = 25
CoreName = 'StatCore'
#groove dimensions
R1 = 4
H1 = 13
B1 = 6
L1 = 2
#wire d
Dh = 0.5
#insul thkn
Hsz = 0.1
#outer d
Dk = Dh + 2*Hsz
#gap 
Lr =0.05
#basic dist
A  = Dk + Lr

y_incr = A*sqrt(3)/2

wire_collection = []
gr_cont_pts = [] 
gr_cont_pts_v = []
pnts = [] 
macropath = "C:\\Users\\papa\\AppData\\Roaming\\FreeCAD\\Macro\\"

#endregion variables

#region main
"""
1 geom meretek atadasa
2 C_BdWires body elhelyezese a horonyban
3 a horony konturjanak lekerdezese osztopontokkal (list, App.Vector)
4 korok poziciojanak elkeszitese
5 korok elkeszitese, konturpontok
vizsgalat
"""
if App.ActiveDocument is not None and App.ActiveDocument.Name == "Workfile":
    pass
else:
    App.open(macropath+"Workfile.FCStd")
    App.setActiveDocument("Workfile")
#1
dim_settings('GrooveV1')

#2
v_gr_base = App.Vector(0,App.ActiveDocument.getObject("GrooveV1").getDatum("V1P1"),0)
v_gr_dir = App.Vector(0,App.ActiveDocument.getObject("GrooveV1").getDatum("V1P2"),0)
v_dir = v_gr_dir.sub(v_gr_base).normalize()
base_dir = App.Vector(0,1,0)
App.ActiveDocument.getObject("C_BdWires").Placement.Base = v_gr_base
App.ActiveDocument.getObject("C_BdWires").Placement.Rotation = def_quaternion(base_dir,v_dir)
App.ActiveDocument.recompute()
#3
gr_cont_pts_ = groove_contour()

for pts in gr_cont_pts_:
    vec1 = (App.Vector(v_gr_base[0],v_gr_base[1])).sub(App.Vector(pts[0],pts[1]))
    gr_cont_pts.append((vec1[0],vec1[1]))

wloc_in_groove()
#endregion main